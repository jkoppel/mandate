This gallery contains example CFGs generated by Mandate. All of these CFGs were generated from the source code plus the operational semantics of the corresponding language, with only a small amount of effort needed to define abstractions to determine what type of CFG is generated.

This gallery contains examples in Imp, Tiger, and MITScript. For each example, we have included the source code, the .dot files generated by Mandate, and the .svg images created by graphviz. For each CFG, we generated two visualizations. In the "long" form, each graph node is labeled with the corresponding abstract state. Because each abstract state contains the full stack at that point in the program, these graphs get unreadably large for all but the smallest programs. We hence also generated a "short" form, where each graph node is labeled with only the term portion of the corresponding abstract state.

A few surprising facts about the shape of generated graphs:

* At the basic level, there will be one CFG node for each "step," and the number of steps depends on the semantics. All 3 languages represent lists of statements by nesting a binary "sequence" node, and so going from one statement to the next takes multiple steps: for (Seq s1 (Seq s2 rest)), it will first evaluate s1 to "skip", then focus on (Seq s2 rest), and then focus on s2. While surprising those more used to hand-written compilers than semantics, this behavior is arguably desirable, and some of our hand-written CFG generators in past projects have the exact same behavior. These "extra steps" can be eliminated with projections.

* It is possible for different parts of the program to yield the same abstract state. For instance, running value-irrelevance on the expression "if foo then 1 else 2" yields "if * then * else *", in which both branches are identical. A CFG generated for this program will appear not to branch. (And indeed, it quite arguably doesn't branch.) This case is not particularly common and does not appear in this gallery. However, something that is common is for the tail of both branches of an if-statement to merge together sooner than you'd expect.

IMP Examples

We wrote the initial example from the paper in Imp, and generated CFGs using the value irrelevance, expression irrelevance, and boolean-tracking abstractions.

There is no Imp parser. Instead, all Imp programs are defined by directly writing the abstract-syntax in Haskell. Here is the definition of this example program:

termBalanceParens :: Term ImpLang
termBalanceParens =
    Seq ("prec" := ReadInt)
    $ Seq ("left" := ReadInt)
    $ Seq ("right" := ReadInt)
    $ Seq ("b" := (LT (varExp "prec") (intConst 5)))
    $ Seq (If (varExp "b")
             (Write (strConst "("))
             Skip)
    $ Seq (WriteInt (varExp "left"))
    $ Seq (Write (strConst "+"))
    $ Seq (WriteInt (varExp "right"))
    $ (If (varExp "b")
          (Write (strConst ")"))
          Skip)


Tiger examples

All of these examples are taken from the Tiger testcases ( https://www.cs.princeton.edu/~appel/modern/testcases/ ).

These graphs are all generated with the value-irrelevance abstraction. Because Tiger is a functional language, everything is an expression, and hence expression-irrelevance is not very interesting. However...

MITScript examples

...the expression-irrelevance abstraction works perfectly fine in MITScript, and produces some nice graphs. These examples were taken from the test suite of the compilers course for which MITScript was created.
